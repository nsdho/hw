实验报告
该实验主要分为2个部分，其中第一部分是模拟cache的c语言程序，第二部分是优化特定维的矩阵转置以减少cache miss。
第一部分的实验主要分为读取命令行，初始化cache，向cache中存放数据，以及cache中某一组满后的块替换策略。
这一部分中命令行的读取主要由getopt函数实现，在参数的读取之外还需实现打印帮助菜单的功能，以响应-h命令或者错误命令的输入，这一功能由printHelpMenu()函数实现。cache的初始化则根据输入的参数计算出所需的cache大小由malloc分配空间。而块替换策略则采用简化的LRU算法。初始化时所有LruNumber均为0。当某组中的某行hit 或者加载缓存成功时赋值LruNumber为10000，而该组中的其他行LruNumber全部减一。当eviction 时，选择最小LruNumber的行进行evict。对于cache的具体操作则通过主函数读取trace文件获得，然后调用相关函数进行。
第二部分的实验主要是对于32*32，64*64，61*67的矩阵的转置操作进行优化。
其中，由于cache为block大小为32包含32个块的直接映射，而一个块包含8个int。对于32*32的矩阵，可通过将其分为8*8的块，由于矩阵中一行只有32个int，8*8的矩阵在cache恰好没有冲突，从而可以达到减小miss的目的。对于61*67的矩阵，由于要求较低，可直接对其进行分块处理，经测试将其分为17*17的块可在分块方案中得到最小的miss。而最优解或是较优解的获得，需要考虑剩余行列数目，并没有想到比较好的方法。对于64*64的矩阵，由于一行有64个int，从而相距4行的数据在cache中冲突，因而采用8*8的分块写矩阵是会由于冲突产生较大数量的cache miss，而采用4*4的分块虽然解决的冲突的问题，但由于并没有充分利用cache中块包含8个int的性质，并不能达到要求的cache miss数。最终，我选择将8*8的矩阵分为4个4*4的矩阵，对于A，即意味着分为A11，A12，A21，A22四个部分，B分为B11，B12，B21，B22四个部分。首先将A11的转置存入B11，A12的转置存入B12，这一操作并不会引发cache中的冲突，只存在不可避免的miss。然后将B11的取出，读入A21并将其转置写入B11，然后将B11的内容写入B21，此时的cache只有加入B21和B22的4个块的必然出现的miss。最后将A22的转置写入B22，从而完成整个块的转置。
通过此次实验，我对于cache的具体结构与模拟有了更深的理解，并且对于getopt这一函数以及valgrind这一工具也有了初步的认识。在对于矩阵转置的优化中，我看到了最简单的程序与刻意优化的程序在cache miss数量上的显著差距，体会到了编程时对于计算机低层体系结构的认识与刻意优化对于程序运行效率的改善与提高，认识到了对于相关体系结构的认知对于编写相应程序的重要作用。
